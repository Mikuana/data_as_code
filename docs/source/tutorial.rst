.. module:: data_as_code
    :noindex:

Tutorial
========

This document provides a high-level overview of how to use this package. This
guide will cover:

 * :ref:`recipe`
 * :ref:`step`
 * :ref:`package`


.. _recipe:

Recipe
------

Every time you use this package, you will begin and end with a
:class:`Recipe`. The recipe acts as a container, which
isolates the package from your regular file-system, and isolates each step from
each other. This is accomplished through liberal use of temporary directories.
The isolation allows the recipe to handle the artifacts involved in each step in
an object-oriented fashion, improving reproducibility of the recipe.

.. note::
    The use of temporary directories means that everything generated by a recipe
    will be discarded at the end, unless otherwise indicated by the user in the
    ``keep`` parameter of the Recipe.

The :class:`Recipe` can be managed with a context handler:

.. code-block:: python

    from data_as_code import Recipe, premade

    class MyRecipe(Recipe):
        pass

or with an equivalent call to begin/end:

.. code-block:: python

    from data_as_code import Recipe, premade

    r = Recipe('data_package')
    r.begin()
    r.end()

.. note::
    This document will use begin/end for its examples, as it is very useful
    during the initial development of a recipe (it keeps the workspace open
    between commands). However, it is best to use the context handler for the
    final script.

.. _step:

Step
------

Once you've started your recipe, you need to include some steps to generate a
data product for the package. Every step requires a
:class:`Recipe` as an input, and must write a file to the
path specified in the ``output`` attribute for the step.

Steps can be broken into two main types:

    1. *Pre-made*: methods which execute a pre-determined set of instructions
    using a set of parameters. These simplify common tasks such as downloading
    a file from the internet, or unzipping an archive

    2. *Custom*: sub-classes which are defined in the recipe, and allow for
    complete control over the instructions that are executed

We'll start with a pre-made step which downloads a file. The premade
:meth:`premade.source_http` uses the URL we provide to download
the html page, storing it inside a temporary working directory that was
established by our recipe.

.. code-block:: python

    from data_as_code import Recipe
    from data_as_code.premade import source_http

    r = Recipe('data_package')
    r.begin()

    data = source_http(r, 'https://en.wikipedia.org/wiki/Data')


Next, we'll make some modifications to the file we downloaded. This time we'll
need to use a custom :class:`Step`. We're going to modify
the text of our downloaded file, replacing all instances of the word "Data"
with "Code".

To create a custom step, we need to create a
`subclass <https://docs.python.org/3/tutorial/classes.html#inheritance>`_
of a :class:`Step`. At the least, we will need to overwrite
the :meth:`Step.instructions` method. These instructions
execute when your custom step is initialized.

For our instructions to work, we need **input** and **output**.
We need to provide the results of our first step as an ingredient for the second.
This is accomplished by defining ``x`` as a class attribute using the
:meth:`ingredient` method: ``x = ingredient(data)``.
This allows us to call the results of the first step as class attribute ``x``
inside of the instructions, even if the file that is being referenced doesn't
exist yet. Second, we need to write our final results to the path mapped to the
``output`` class attribute

.. code-block:: python

    from data_as_code import Step, ingredient

    class DataAsCode(Step):
        """ Make Data into Code """
        product = True
        output = 'data_as_code.html'
        x = ingredient(data)

        def instructions(self):
            self.output.write_text(
                self.x.path.read_text().replace('Data', 'Code')
            )

    DataAsCode(r)
    r.end()

We want to save the results of our custom step to the data package produced by
the recipe, so we set the attribute ``product = True``. Because of this, we also
have to provide an explicit output file name to be used by the output (if a step
is not marked as a product, the path name is unnecessary and an automatically
generated default path can be used instead).

Once the custom step is executed, we end the recipe, and the result is saved to
our data package created at the path specified in the recipe workspace, in the
form of an archive file which contains (among other things) the file ``data_as_code.html``.

We can rewrite our steps into a single script, and make it slightly more concise
using a context handler instead of an explicit call to begin/end.

.. code-block:: python

    from data_as_code import Step, ingredient, Recipe
    from data_as_code.premade import source_http

    with Recipe('data_package') as r:
        wiki_page = source_http(r, 'https://en.wikipedia.org/wiki/Data')


        class DataAsCode(Step):
            """ Make Data into Code """
            product = True
            output = 'data_as_code.html'
            x = ingredient(wiki_page)

            def instructions(self):
                self.output.write_text(
                    self.x.path.read_text().replace('Data', 'Code')
                )


        DataAsCode(r)


.. _package:

Package
-------

.. code-block:: shell

    | data_package/
    |-- env/
        |-- requirements.txt
    |-- metadata/
        |-- data_as_code.html.json
    |-- data/
        |-- data_as_code.html
    |-- recipe.py
    |-- .dacpackage
