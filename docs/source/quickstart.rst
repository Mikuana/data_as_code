Quickstart
==========

This document provides a high-level overview of how to use this package. This
guide will cover:

 * :ref:`recipe`
 * :ref:`step`
 * :ref:`package`


.. _recipe:

Recipe
------

Every time you use this package, you will begin and end with a
:py:class:`~data_as_code.recipe.Recipe`. The recipe acts as a container, which
isolates the package from your regular file-system, and isolates each step from
each other. This is accomplished through liberal use of temporary directories.
The isolation allows the recipe to handle the artifacts involved in each step in
an object-oriented fashion, improving reproducibility.

.. note::
    The use of temporary directories means that everything generated by a recipe
    will be discarded at the end, unless otherwise indicated by the user in the
    ``keep`` parameter of the Recipe.

The :py:class:`~data_as_code.recipe.Recipe` can be managed with a context handler:

.. code-block:: python

    from data_as_code import Recipe, premade

    with Recipe('data_package') as r:
        pass

or with an equivalent call to begin/end:

.. code-block:: python

    from data_as_code import Recipe, premade

    r = Recipe('data_package')
    r.begin()
    r.end()

.. note::
    This document will use begin/end for its examples, as it is very useful
    during the initial development of a recipe (it keep the workspace open
    between commands). However, it is best to use the context handler for the
    final script.

.. _step:

Step
------

Once you've started your recipe, you need to include some steps to generate a
data product to be included in the package. Every step requires a
:py:class:`~data_as_code.recipe.Recipe` as an input, and must write a file to the
path specified in the ``output`` attribute defined for the step.

Steps can be broken into two main types:

    1. *Pre-made*: methods which execute a pre-determined set of instructions
    using a set of parameters. These simplify common tasks such as downloading
    a file from the internet, or unzipping an archive

    2. *Custom*: sub-classes which are defined in the recipe, and allow for
    complete control over the instructions that are executed

We'll start with a pre-made step which downloads a file.

.. code-block:: python

    from data_as_code import Recipe
    from data_as_code.premade import source_http

    r = Recipe('data_package')
    r.begin()

    data = source_http(r, 'https://en.wikipedia.org/wiki/Data')


The premade :py:meth:`~data_as_code.premade.source_http` uses the URL we provided
to download the html page, storing it inside a temporary working directory that was
established by our recipe. Next, we'll make some modification to the file we
downloaded. This time we'll need to use a custom :py:class:`data_as_code._step.Step`.

.. code-block:: python

    from data_as_code import Step, ingredient

    class DataAsCode(Step):
        """ Make Data into Code """
        product = True
        output = 'data_as_code.html'
        x = ingredient()

        def instructions(self):
            self.output.write_text(
                self.x.path.read_text().replace('Data', 'Code')
            )

    new_data = DataAsCode(r)


.. _package:

Package
-------
